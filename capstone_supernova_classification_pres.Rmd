---
title: "capstone_supernova_classification"
output: pdf_document
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This part of the presentation will be focusing on the classification of supernova types based on standards developed for classification using absolute magnitude and MJD 


## Imports and data init
```{r}
library(tidyverse)
library(dplyr)
library(rpart)
library(rpart.plot)

lightcurve_data_b_1 <- read.csv("plasticc_test_set_batch1.csv")
lightcurve_train <- read.csv("plasticc_train_lightcurves.csv")
meta_data_test <- read.csv("plasticc_test_metadata.csv")
meta_data_train <- read.csv("plasticc_train_metadata.csv")
```


## Helper function init
```{r pressure, echo=FALSE}
get_zero_point_flux_mag <- function(filter){
  f_0 = 0
  #m_0 = 0
    if(filter == "u"){
      f_0 = 1810#Jy
      #m_0 = 23.9#Jy
  } else if (filter == "g"){ #SDSS passbands calculated with Vega as zero point reference
    f_0 = 3640
    #m_0 = 25.1
  } else if (filter == "r"){
    f_0 = 3080
    #m_0 = 24.4
  } else if (filter == "i"){
    f_0 = 2550
    #m_0 = 24.1
  } else if (filter == "z"){
    f_0 = 1800
    #m_0 = 22.8
  } else if (filter == "y"){ 
    f_0 = 1080
    #m_0 = 20.9
  }
  else{
    f_0 = NULL
    #m_0 = NULL
  }
  return(f_0)
}

calculate_apparent_magnitude <- function(flux, filter){
  # We assume the flux of the objects are already converted to Jy
  f <- abs(flux) # to avoid NaNs from log(-x)
  return(-2.5 * log10(f/get_zero_point_flux_mag(filter)))
}

calculate_absolute_magnitude <- function(flux, distance, filter) {
  # We assume the flux of the objects are in nanomaggies given their size.
  # We assume distance is in the modulus scale
  # We assume filter is one of (u g r i z y)
  # Values of f_0 are using SDSS standards.
  f <- abs(flux) * 3.631 * 10^(-6) # to avoid NaNs from log(-x) and to convert to Jy from nanomaggies
  apparent_magnitude <- calculate_apparent_magnitude(f, filter)
  return(apparent_magnitude - distance)
}

calculate_luminosity <- function(flux, distmod){
  # We assume flux is in nanomaggies
  # We assume distmod is in distmod
  distance_parsec = 10^(distmod/5 + 1)
  flux_erg = flux * 3.631e-6 * 10^(-0.4*distmod) 
  return(4*pi * (distance_parsec)^2 * flux_erg)
}

get_days_to_10pct_luminosity <- function(df){
  max_luminosity <- df %>%
  group_by(object_id) %>%
  summarize(max_lum = max(luminosity)) %>%
  ungroup()

  mjd_max_luminosity <- df %>%
    inner_join(max_luminosity, by = c("object_id", "luminosity" = "max_lum")) %>%
    select(object_id, mjd)
  
  first_max_mjd <- first(mjd_max_luminosity$mjd)
  
  # We assume the luminosity data for the dataframe has been calculated
    first_10pct_lumin <- df %>% group_by(object_id) %>% filter(luminosity <= 0.1 * max(luminosity), mjd > first_max_mjd)
    mjd_first_10pct_lumin <- head(first_10pct_lumin, 1)$mjd
    
    return(first_max_mjd - mjd_first_10pct_lumin)
}

get_lightcurve_summary <- function(lightcurve_data_param, potential_supernovas_param){
  
  # lightcurve_data_param <- light_train
  # potential_supernovas_param <- potential_supernovas_train
  
  filter_lightcurve_data <- lightcurve_data_param %>% filter(flux != 0, object_id %in%
                                                               potential_supernovas_param$object_id)
  passbands = c("u", "g", "r", "i", "z", "y")
  mut_filter_lightcurve_data <- filter_lightcurve_data %>% mutate(passband_letter = passbands[passband + 1])
  
  mut_meta_lightcurve_merge <- merge(mut_filter_lightcurve_data, potential_supernovas_param, by = "object_id", all.x = TRUE)

  mut_meta_lightcurve_merge_abs_mag <- mut_meta_lightcurve_merge %>% rowwise() %>% mutate(
  absolute_magnitude = calculate_absolute_magnitude(flux, true_distmod, passband_letter),
  luminosity = calculate_luminosity(flux, true_distmod)) # calculate per passband??
  

  # mut_meta_lightcurve_merge_abs_mag_lumin_10 <- mut_meta_lightcurve_merge_abs_mag %>% group_by(object_id) %>% mutate(luminosity_10pct = first_10pct_lumin)
  
  # mut_meta_lightcurve_merge_abs_mag_luminosity_10pct <- mut_meta_lightcurve_merge_abs_mag %>% group_by(object_id) %>% mutate(luminosity_10pct = head(mut_meta_lightcurve_merge_abs_mag %>% filter(luminosity <= 0.1 * max(luminosity)) , 1)$luminosity)

  merge_summary <- mut_meta_lightcurve_merge_abs_mag %>% group_by(object_id) %>% summarise(
    object_id = object_id,
    class_label = true_target,
    absolute_magnitude = absolute_magnitude,
    max_absolute_magnitude = max(absolute_magnitude),
    min_absolute_magnitude = min(absolute_magnitude),
    absolute_magnitude_range = abs(min(absolute_magnitude) - max(absolute_magnitude)),
    max_luminosity = max(luminosity),
    days_to_10pct = get_days_to_10pct_luminosity(mut_meta_lightcurve_merge_abs_mag),
    days_to_peak = true_peakmjd - min(mjd), #change to index of peak luminosity
    passband = passband,
    mjd_range = max(mjd) - min(mjd))

  return(merge_summary)
}

```


The provided data-set defines 14 class labels that correspond to differnt transient events. The ones were are interested in are:
  class 6: SNIa (Type Ia supernova)
  class 16: SNIbc (core-collapse supernova Type Ibc)
  class 42: SNIIn (Type IIn supernova)
  class 52: SNII (core-collapse supernova Type II)
  class 53: SNIIL (Type II-L supernova)
  class 62: SNIIb (Type IIb supernova)

## Object classification
```{r}
light_train <- lightcurve_train
light_test <- lightcurve_data_b_1


potential_supernovas_train <- meta_data_train %>% filter(true_target <= 95, true_target %in% c(6, 16, 42, 52, 53, 62)) # these values represent (SNIa, SNIbc, SNIIn, SNII, SNIIL, SNIIb)
## Research shows that only 14 class labels are recognized, anything greater than this is not a value that can be classified by this algorithm.

potential_supernovas_test <- meta_data_test %>% filter(true_target <= 95, true_target %in% c(6, 16, 42, 52, 53, 62))
#potential_supernovas %>% ggplot() + aes(x=true_target) + geom_bar() + ggtitle("Distribution of true_target for objects that are most likley supernovas")
#meta_data %>% ggplot() + aes(x=true_target) + geom_bar() + ggtitle("Distribution of true_target for objects in meta data")


train_summary <- get_lightcurve_summary(light_train, potential_supernovas_train)
test_summary <- get_lightcurve_summary(light_test, potential_supernovas_test)

# weights <- rep(1, nrow(train_summary))
# weights[train_summary$absolute_magnitude != 0] <- 0.001
# weights[train_summary$mjd_range != 0] <- 10

classification_model = rpart(class_label ~ max_absolute_magnitude + min_absolute_magnitude + days_to_peak, data = train_summary, method = 'class')
classification_model$variable.importance

rpart.plot(classification_model) # model is not displaying all classification

predict_test <- predict(classification_model, test_summary, type = "class")
confusion_matrix <- table(test_summary$class_label, predict_test)
confusion_matrix

```


